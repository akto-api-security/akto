/* eslint-disable no-loop-func */
import { Box, Divider, Frame, HorizontalStack, Text, TopBar, VerticalStack } from '@shopify/polaris'
import React, { useEffect, useRef } from 'react'
import api from '../api'
import issuesApi from '@/apps/dashboard/pages/issues/api'
import func from '@/util/func'
import { useState } from 'react'
import "./styles.css"
import ReportTOC from './ReportTOC'
import { useParams } from 'react-router-dom'
import transform from '../transform';
import ReportHeader from './ReportHeader'
import ReportSummary from './ReportSummary'
import ReportFindings from './ReportFindings'
import ReportConclusion from './ReportConclusion'
import reportTransform from './transform'
import LocalStore from '../../../../main/LocalStorageStore'

const VulnerabilityReport = () => {
    const [loading, setLoading] = useState(true)
    const [pdfDownloadEnabled, setPdfDownloadEnabled] = useState(false)
    const [categoryVsIssuesMap, setCategoryVsIssuesMap] = useState({})
    const [categoryMap, setCategoryMap] = useState({})
    const [severitiesCount, setSeveritiesCount] = useState({ HIGH: 0, MEDIUM: 0, LOW: 0 })
    const [categoryVsApisCountMap, setCategoryVsApisCountMap] = useState({})
    const [aktoFindingsTableData, setAktoFindingsTableData] = useState([])
    const [ aktoRecommendations, setAktoRecommendations ] = useState([])
    const [graphData, setGraphData] = useState([])
    const [totalIssues, setTotalIssues] = useState(0)
    const [severityMap, setSeverityMap] = useState({})
    const [startTime, setStartTime] = useState(0)
    const [endTime, setEndTime] = useState(0)
    const [totalApisTested, setTotalApisTested] = useState(0)
    const [subCategoryMap, setSubCategoryMap] = useState({})

    const pdfRef = useRef()
    const params = useParams()
    const testingRunSummaryId = params.summaryId
    const issuesFilter = params.issuesFilter

    const organizationName = func.capitalizeFirstLetter(window.ACCOUNT_NAME || "")
    const [currentDate, setCurrentDate] = useState(func.formatReportDate(new Date()))
    const userName = func.capitalizeFirstLetter(window.USER_NAME.split('@')[0] || "")

    const aktoFindingsChildren = []
    Object.keys(categoryVsIssuesMap).forEach((categoryName, index) => {
        const issuesArr = categoryVsIssuesMap[categoryName]
        issuesArr.map((issue) => {
            aktoFindingsChildren.push({
                text: issue.testName,
                link: issue.testName,
                children: null,
            })
        })
    })

    const tocList = [
        { text: "Report summary", link: "report-summary", children: null },
        { text: (<>Akto findings for <span id='organization-name'>{organizationName}</span></>), link: "findings-table", children: aktoFindingsChildren },
        { text: "Conclusion and Next Steps", link: "akto-next-step", children: null },
    ]

    const fetchSubcategoriesAndCategories = async () => {
        const metaDataObj = await transform.getAllSubcategoriesData(true, "runTests")
        return [metaDataObj.subCategories, metaDataObj.categories]
    }

    const getMinMaxTimestamps = (data) => {
        let minStart = Number.MAX_VALUE
        let maxEnd = Number.MIN_VALUE

        for(let index = 0; index < data.length; index++) {
            if(minStart > data[index].startTimestamp) {
                minStart = data[index].startTimestamp
            }

            if(maxEnd < data[index].endTimestamp) {
                maxEnd = data[index].endTimestamp
            }
        }

        if(minStart === Number.MAX_VALUE) {
            minStart = 0
        }

        if(maxEnd === Number.MIN_VALUE) {
            maxEnd = 0
        }

        setStartTime(minStart)
        setEndTime(maxEnd)
    }

    const fetchVulnerableData = async () => {
        let resultsCount = 0;
        let vulnerableTestingRunResults = []
        let hasStartEndTime = false

        if (testingRunSummaryId) {
            await api.fetchTestingRunResultsSummary(testingRunSummaryId).then((resp) => {
                if(resp.state === 'COMPLETED') {
                    setStartTime(resp.startTimestamp)
                    setEndTime(resp.endTimestamp)
                    hasStartEndTime = true
                    setCurrentDate(func.getFormattedDate(resp.endTimestamp))
                } else {
                    setCurrentDate(func.getFormattedDate(resp.startTimestamp))
                }
            })
            
            while (true) {
                let testingRunCountsFromDB = 0
                await api.fetchVulnerableTestingRunResults(testingRunSummaryId, resultsCount).then(async(resp) => {
                    let issueIds = resp.testingRunResults.map((x) => {
                        return {
                            apiInfoKey: x.apiInfoKey,
                            testErrorSource: "AUTOMATED_TESTING",
                            testSubCategory: x.testSubType
                        }
                    })
                    await issuesApi.fetchIssuesFromResultIds(issueIds, ["IGNORED", "FIXED"]).then((new_resp) => {
                        let nonVulTests = new Set((new_resp || []).map(x => 
                            x.id.apiInfoKey.url + "??##" + x.id.apiInfoKey.method + "??##" + x.id.apiInfoKey.apiCollectionId + "??##" + x.id.testSubCategory
                        ));
                        let filteredTests = resp.testingRunResults.filter((x) => {
                            let tempId = x.apiInfoKey.url + "??##" + x.apiInfoKey.method + "??##" + x.apiInfoKey.apiCollectionId + "??##" + x.testSubType
                            return !nonVulTests.has(tempId)
                        })
                        vulnerableTestingRunResults = [...vulnerableTestingRunResults, ...filteredTests]
                    })
                    testingRunCountsFromDB = resp.testingRunResults.length
                })
                resultsCount += 50
                if (testingRunCountsFromDB < 50) {
                    //EOF: break as no further documents exists
                    break
                }
            }
        } else if (issuesFilter) {
            while (true) {
                let testingRunCountsFromDB = 0
                let filters = JSON.parse(atob(issuesFilter))
                await issuesApi.fetchVulnerableTestingRunResultsFromIssues(filters, resultsCount).then(resp => {
                    vulnerableTestingRunResults = [...vulnerableTestingRunResults, ...resp.testingRunResults]
                    testingRunCountsFromDB = resp.totalIssuesCount
                    //sampleDataVsCurlMap = { ...sampleDataVsCurlMap, ...resp.sampleDataVsCurlMap }
                })
                resultsCount += 50
                if (testingRunCountsFromDB < 50 || resultsCount >= 1000) {
                    //EOF: break as no further documents exists
                    break
                }
            }
        }

        const localCategoryMap = LocalStore.getState().categoryMap
        const localSubCategoryMap = LocalStore.getState().subCategoryMap
        let shouldFetchSubcategoriesAndCategories = false
        if (
            (!localCategoryMap || Object.keys(localCategoryMap).length === 0) ||
            (!localSubCategoryMap || Object.keys(localSubCategoryMap).length === 0)
        ) {
            shouldFetchSubcategoriesAndCategories = true
        }

        let subCategories
        let categories
        if(shouldFetchSubcategoriesAndCategories) {
            let res = await fetchSubcategoriesAndCategories()
            subCategories = res[0]
            categories = res[1]
        } else {
            subCategories = Object.values(localSubCategoryMap)
            categories = Object.values(localCategoryMap)
        }

        let subCategoryMap = {};
        subCategories.forEach((x) => {
            subCategoryMap[x.name] = x;
        });

        setSubCategoryMap(subCategoryMap)

        let categoryMap = {};
        categories.forEach((category) => {
            categoryMap[category.name] = category;
        });

        if(!hasStartEndTime) {
            getMinMaxTimestamps(vulnerableTestingRunResults)
        }

        const vulMap = reportTransform.createVulnerabilityMap(vulnerableTestingRunResults, categoryMap, subCategoryMap)
        setSeveritiesCount(vulMap.severitiesCount)
        setTotalApisTested(vulMap.totalApisTested)
        setTotalIssues(vulMap.totalIssues)
        setCategoryMap(vulMap.categoryMap)
        setCategoryVsIssuesMap(vulMap.categoryVsIssuesMap)
        setCategoryVsApisCountMap(vulMap.categoryVsApisCountMap)
        setAktoFindingsTableData(vulMap.aktoFindingsTableData)
        setAktoRecommendations(vulMap.aktoRecommendations)
        setGraphData(vulMap.graphData)

        const severityMapRes = reportTransform.createVulnerableAPIsSeverity(vulnerableTestingRunResults, categoryMap)
        setSeverityMap(severityMapRes)
    }

    useEffect(() => {
        setLoading(true)
        setPdfDownloadEnabled(false)
        fetchVulnerableData()
        setLoading(false)
        setPdfDownloadEnabled(true)
    }, [])


    const handleDownloadPF = async () => {
        const WAIT_DURATION = 2500, MAX_RETRIES = 15
        const reportUrl = window.location.href
        
        let pdfError = ""
        let status
        let pdf

        setPdfDownloadEnabled(false)

        const progressToastInterval = setInterval(() => {
            func.setToast(true, false, "Report PDF generation in progress. Please wait...")
        }, 1000)

        try {
            // Trigger pdf download
            const startDownloadReponse = await api.downloadReportPDF(null, organizationName, currentDate, reportUrl)
            const reportId = startDownloadReponse?.reportId
            status = startDownloadReponse?.status

            if (reportId !== null && status === "IN_PROGRESS") {
                // Poll for PDF completion
                for(let i = 0; i < MAX_RETRIES; i++) {
                    const pdfPollResponse = await api.downloadReportPDF(reportId, organizationName, currentDate, reportUrl)
                    status = pdfPollResponse?.status

                    if (status === "COMPLETED") {
                        pdf = pdfPollResponse?.pdf
                        break
                    } else if (status === "ERROR") {
                        pdfError = "Failed to download PDF"
                        break
                    }

                    await func.sleep(WAIT_DURATION)

                    func.setToast(true, false, "Report PDF generation in progress. Please wait...")
                }
            } else {
                pdfError = "Failed to start PDF download"
            }
        } catch (err) {
            pdfError = err.message
        }

        clearInterval(progressToastInterval)

        if (status === "COMPLETED") {
            if (pdf === undefined) {
                pdfError = "Failed to download PDF"
            }
            else {
                // Download the PDF
                try {
                    const byteCharacters = atob(pdf);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: "application/pdf" });
                    const link = document.createElement("a");
                    link.href = window.URL.createObjectURL(blob);
                    link.setAttribute("download", "akto_security_findings.pdf");
                    document.body.appendChild(link);
                    link.click();
                    func.setToast(true, false, "Report PDF downloaded.")
                } catch (err) {
                    pdfError = err.message
                }
            }  
        }
        
        if (pdfError !== "") {
            func.setToast(true, true, `Error while downloading PDF. Please try again. \nError: ${pdfError}`)
        } 

        setPdfDownloadEnabled(true)
    }

    const reportSecondaryMenu = (
        <div className="report-header-css header-css" id="report-secondary-menu-container">
            <Box width="100%">
                <HorizontalStack align="space-between">
                    <VerticalStack>
                        <Text variant="headingXs">{organizationName} API Security Findings</Text>
                        <Text variant="bodySm">{currentDate}</Text>
                    </VerticalStack>
                    <div style={{ display: 'flex', alignItems: 'center' }}>
                        {/* <Button primary onClick={() => handleDownloadPF()} disabled={!pdfDownloadEnabled}>Download</Button> */}
                        <img src='/public/white_logo.svg' alt="Logo" className='top-bar-logo' />
                    </div>
                </HorizontalStack>
            </Box>
        </div>
    )

    const reportTopBar = (
        <TopBar secondaryMenu={reportSecondaryMenu} />
    )

    const reportSummaryItems = [
        {
            title: "Total Vulnerable APIs",
            data: totalApisTested,
        },
        {
            title: "Vulnerable Issues",
            data: totalIssues
        },
        {
            title: "Scan Duration",
            data: issuesFilter ? '-' : func.getTimeTakenByTest(startTime, endTime)
        }
    ]

    return (
        <Frame topBar={reportTopBar}>
            <div ref={pdfRef} id="report-container">
                <Box background="bg">
                    <ReportHeader userName={userName} organizationName={organizationName} currentDate={currentDate} />
                    <ReportTOC tocList={tocList}/>

                    <div className="report-page-break"></div>
                    <Box paddingInlineStart={5} paddingInlineEnd={5}>
                        <Divider />
                    </Box>

                    <ReportSummary
                        reportSummaryItems={reportSummaryItems}
                        severityMap={severityMap}
                        graphData={graphData}
                        organizationName={organizationName}
                        currentDate={currentDate}
                    />

                    <div className="report-page-break"></div>
                    <Box paddingInlineStart={5} paddingInlineEnd={5}>
                        <Divider />
                    </Box>

                    <ReportFindings
                        aktoFindingsTableData={aktoFindingsTableData}
                        categoryMap={categoryMap}
                        categoryVsApisCountMap={categoryVsApisCountMap}
                        categoryVsIssuesMap={categoryVsIssuesMap}
                        organizationName={organizationName}
                        subCategoryMap={subCategoryMap}
                    />

                    <div className="report-page-break"></div>
                    <Box paddingInlineStart={5} paddingInlineEnd={5}>
                        <Divider />
                    </Box>

                    <ReportConclusion aktoRecommendations={aktoRecommendations} />
                </Box>
            </div>
        </Frame>
    )
}

export default VulnerabilityReport