import { Badge, Box, Link } from "@shopify/polaris"
import func from "@/util/func"

const reportTransform = {
    createVulnerableAPIsSeverity: (vulnerableTestingRunResults) => {
        const countMap = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
        }

        vulnerableTestingRunResults.forEach(item => {
            const confidence = item.testResults.filter((result) => {
              return result.vulnerable
            }).map((result) => result.confidence)[0]
            countMap[confidence]++
        })

        const result = {
            "Critical": {
                "text": countMap.CRITICAL || 0,
                "color": func.getHexColorForSeverity("CRITICAL"),
                "filterKey": "Critical"
            },
            "High": {
                "text": countMap.HIGH || 0,
                "color": "#EF864C",
                "filterKey": "High"
            },
            "Medium": {
                "text": countMap.MEDIUM || 0,
                "color": "#F6C564",
                "filterKey": "Medium"
            },
            "Low": {
                "text": countMap.LOW || 0,
                "color": "#6FD1A6",
                "filterKey": "Low"
            }
        }
        return result
    },

    getTotalUniqueApis: (vulnerableTestingRunResults) => {
        const uniqueApis = new Set()
        vulnerableTestingRunResults.forEach(item => {
            const endpointKey = `${item.apiInfoKey.apiCollectionId}-${item.apiInfoKey.method}-${item.apiInfoKey.url}`
            uniqueApis.add(endpointKey)
        })

        return uniqueApis.size
    },

    createVulnerabilityMap: (testingRunResults, categoryMap, subCategoryMap) => {
        let result = {}
        let categoryVsIssuesMap = {}
        let categoryVsApisCountMap = {}
        let issueVsVulMap = {}
        let aktoFindingsTableData = []
        let aktoRecommendationsData = []
        let high = 0
        let medium = 0
        let low = 0
        let totalIssuesCount = 0
        testingRunResults?.length > 0 && testingRunResults.forEach((testingRun) => {
            let testSubtype = testingRun?.testSubType
            let testInfo = subCategoryMap?.[testSubtype]

            if (!testInfo) {
                return
            }
            let severity = testInfo?.superCategory?.severity?._name
            let severityIndex = 0;
            switch (severity) {
                case 'HIGH':
                    ++high
                    severityIndex = 2
                    break;
                case 'MEDIUM':
                    ++medium
                    severityIndex = 1
                    break;
                case 'LOW':
                    ++low
                    severityIndex = 0
                    break;
                default:
                    break;
            }

            let vulnerabilities = issueVsVulMap[testSubtype]
            if (vulnerabilities === undefined) {
                vulnerabilities = JSON.parse(JSON.stringify(testInfo))
            }
            let vulnerableTestingRunResults = vulnerabilities["vulnerableTestingRunResults"]
            if (vulnerableTestingRunResults === undefined) {
                vulnerableTestingRunResults = []
            }
            vulnerableTestingRunResults.push(testingRun)
            vulnerabilities['vulnerableTestingRunResults'] = vulnerableTestingRunResults
            vulnerabilities['severityIndex'] = severityIndex
            issueVsVulMap[testSubtype] = vulnerabilities
        })
        result = {
            ...result,
            severitiesCount: { HIGH: high, MEDIUM: medium, LOW: low }
        }
        let severityMapForIssueCategory = {}
        for (const [testSubType, issue] of Object.entries(issueVsVulMap)) {
            const categoryName = issue.superCategory.name
            const severity = issue?.superCategory?.severity?._name

            if (!categoryName) {
                continue
            }

            let issuesList
            if (!categoryVsIssuesMap.hasOwnProperty(categoryName)) {
                issuesList = []
                categoryVsIssuesMap[categoryName] = issuesList
            } else {
                issuesList = categoryVsIssuesMap[categoryName]
            }

            issuesList.push(issue)

            let apisCount = 0
            if (!categoryVsApisCountMap.hasOwnProperty(categoryName)) {
                categoryVsApisCountMap[categoryName] = 0
            } else {
                apisCount = categoryVsApisCountMap[categoryName]
            }

            if(severityMapForIssueCategory.hasOwnProperty(categoryName)){
                let initialCount = severityMapForIssueCategory[categoryName][severity] || 0
                severityMapForIssueCategory[categoryName][severity] = initialCount + issue?.vulnerableTestingRunResults?.length 
            }else{
                severityMapForIssueCategory[categoryName] = {}
                severityMapForIssueCategory[categoryName][severity] = issue?.vulnerableTestingRunResults?.length 
            }

            apisCount += issue.vulnerableTestingRunResults.length
            categoryVsApisCountMap[categoryName] = apisCount

            //Add to akto recommendation
            if (issue.hasOwnProperty("remediation")) {
                aktoRecommendationsData.push({
                    title: issue.testName,
                    content:  issue.remediation
                })
            }
        }
        let totalTemplates = 0
        let graphArr = []

        const sortedCategories = Object.keys(categoryVsIssuesMap)
        .map(categoryName => ({
            categoryName,
            issueCount: categoryVsIssuesMap[categoryName].length
        }))
        .sort((a, b) => b.issueCount - a.issueCount)

        sortedCategories.slice(0, 5).forEach((categoryData, index) => {
            const { categoryName } = categoryData
            graphArr.push({
                text: categoryMap[categoryName]?.displayName,
                value: categoryVsApisCountMap[categoryName],
                color: '#B6B0FE'
            })
        })

        graphArr.sort((a, b) => b.value - a.value)

        let issueSno = 1
        const severityLevels = func.getAktoSeverities().reverse()
        Object.keys(categoryVsIssuesMap).forEach((categoryName, index) => {
            const issuesArr = categoryVsIssuesMap[categoryName]
            totalTemplates += issuesArr.length
            issuesArr.forEach((issue, issueIndex) => {
                const severity = func.getRunResultSeverity(issue.vulnerableTestingRunResults[0], subCategoryMap)
                const severityIndex = severityLevels.indexOf(severity)
                totalIssuesCount += issue.vulnerableTestingRunResults.length
                aktoFindingsTableData.push({
                    key: issueSno,
                    sno: issueSno++,
                    issueNameComp: <Box><Link onClick={(e) => e.stopPropagation()} url={`#${issue.testName}`} removeUnderline><p style={{whiteSpace: 'normal'}}>{issue.testName}</p></Link></Box>,
                    issueName: issue.testName,
                    issueDescriptionComp: <Box><p style={{whiteSpace: 'normal'}}>{(issue.issueDescription.replace(/^"|"$/g, ''))}</p></Box>,
                    issueDescription: issue.issueDescription,
                    apisAffected: issue.vulnerableTestingRunResults.length,
                    issueCategory: issue.superCategory.displayName,
                    issueCategoryComp: <Box><p style={{whiteSpace: 'normal'}}>{issue.superCategory.displayName}</p></Box>,
                    issueImpactComp: <div className={`badge-wrapper-${severity}`}>
                                        <Badge size="small" key={issueIndex+'impact'}>{func.toSentenceCase(severity)}</Badge>
                                    </div>,
                    issueImpact: severityIndex,
                })
            })
        })

        const AKTO_RECOMMENDATIONS_LIMIT = 10
        if (aktoRecommendationsData.length > AKTO_RECOMMENDATIONS_LIMIT) {
            aktoRecommendationsData = aktoRecommendationsData.slice(0, AKTO_RECOMMENDATIONS_LIMIT)
        }

        aktoFindingsTableData.sort((a, b) => b.issueImpact - a.issueImpact)
        aktoFindingsTableData.forEach((item, index) => {
            item.sno = index + 1
        })

        result = {
            ...result,
            totalApisTested: reportTransform.getTotalUniqueApis(testingRunResults) || 0,
            totalIssues: totalIssuesCount || 0,
            categoryMap: categoryMap,
            categoryVsIssuesMap: categoryVsIssuesMap,
            categoryVsApisCountMap: categoryVsApisCountMap,
            aktoFindingsTableData: aktoFindingsTableData,
            aktoRecommendations: aktoRecommendationsData,
            graphData: graphArr
        }

        return result
    }
}

export default reportTransform