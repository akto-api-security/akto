package com.akto.action.gpt.cache;

import com.mongodb.BasicDBObject;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Simple in-memory cache for content analysis results.
 * Supports vulnerability analysis, red teaming, threat analysis, etc.
 */
public class VulnerabilityAnalysisCache {
    
    private static VulnerabilityAnalysisCache instance;
    private final ConcurrentHashMap<String, CacheEntry> cache = new ConcurrentHashMap<>();
    
    // Cache configuration
    private static final int MAX_CACHE_SIZE = 10000;
    private static final long TTL_MINUTES = 48 * 60 * 60; // 48 hours in seconds
    
    private VulnerabilityAnalysisCache() {}
    
    public static synchronized VulnerabilityAnalysisCache getInstance() {
        if (instance == null) {
            instance = new VulnerabilityAnalysisCache();
        }
        return instance;
    }
    
    /**
     * Generates cache key based on analysis type and result ID
     */
    public String generateCacheKey(String analysisType, String resultId, BasicDBObject contentData) {
        if (resultId != null && !resultId.trim().isEmpty()) {
            String type = (analysisType != null) ? analysisType.toLowerCase() : "analysis";
            return type + "_vulnerability:" + resultId;
        }
        return null;
    }
    
    /**
     * Get cached analysis result
     */
    public BasicDBObject get(String key) {
        if (key == null) return null;
        
        CacheEntry entry = cache.get(key);
        if (entry == null) return null;
        
        // Check expiration
        if (System.currentTimeMillis() - entry.timestamp > TTL_MINUTES * 60 * 1000) {
            cache.remove(key);
            return null;
        }
        
        return entry.result;
    }
    
    /**
     * Put analysis result in cache
     */
    public void put(String key, BasicDBObject result) {
        if (key == null || result == null) return;
        
        // Simple size limit
        if (cache.size() >= MAX_CACHE_SIZE) {
            cache.clear(); // Simple approach: clear all when full
        }
        
        cache.put(key, new CacheEntry(result, System.currentTimeMillis()));
    }
    
    /**
     * Cache entry
     */
    private static class CacheEntry {
        final BasicDBObject result;
        final long timestamp;
        
        CacheEntry(BasicDBObject result, long timestamp) {
            this.result = result;
            this.timestamp = timestamp;
        }
    }
}